## (a)

```C
#include <stdio.h>
#include <stdlib.h>

int main(void){
	int i, *v = malloc(4 * sizeof(int));
	
	for (i = 0; i < 4; i++) v[i] = i + 1;
	for (i = 0; i < 4; i++) printf("%d\n", v[i]);
	
	return 0;

}
```
Esse código aloca memória de forma dinâmica e sequencial.

Dinâmica porque o espaço de memória foi reservado em tempo de execução com `malloc`.

Sequencial porque `malloc` retorna um bloco contíguo de memória. Além disso, é possível
observar que não é usado o conceito de nó, logo não pode ser alocação encadeada.


## (b)

```C
#include <stdio.h>
#include <stdlib.h>

typedef struct no {
	int item;
	struct no *prox;
} No;


int main(void){
	
	No v[4] = {{3, v+2}, {1, v+3}, {4, NULL}, {2, v+0}};
	
	for (No *p = v+1; p != NULL; p = p->prox)
		printf("%d\n", p->item);
	return 0;	
}
```

Esse código aloca memória de forma estática e encadeada.

Estática pois o vetor de 4 posições está sendo criado em tempo de compilação, ou seja,
antes do programa iniciar, o computador já armazenou um espaço na memória para guardar 4 nó.

Encadeada pois os elementos estão ligados por meio de nó, onde cada elemento tem um campo
valor e um campo apontando para o próximo elemento.

Quando um elemento tem seu próximo preenchido com NULL, significa que a lista chegou ao fim.

## (c)

```C
#include <stdio.h>
#include <stdlib.h>

typedef struct no {
	int item;
	struct no *prox;
} *Lst;


Lst no(int x, Lst p) {
	Lst n = malloc(sizeof(struct no));
	n->item = x;
	n->prox = p;
	
	return n;
}

int main(void) {
	Lst p = no(1,no(2,no(3,no(4,NULL))));
	
	while (p) {
		printf("%d\n", p->item);
		p = p->prox;
	}
	
	return 0;
}
```

Esse código aloca memória de forma dinâmica e encadeada.

Dinâmica pois cada nó é criado em tempo de execução com `mallloc`.

Encadeada pois cada elemento sabe quem é o seu próximo, por meio da estrutura nó.

