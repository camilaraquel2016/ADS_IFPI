```TypeScript
let c1: Conta = new Conta("1", 100);
let c2: Conta = new Conta("2", 100);
let c3: Conta;

c1 = c2;
c3 = c1;

c1.sacar(10);

c1.transferir(c2, 50);

console.log(c1.consultarSaldo())
console.log(c2.consultarSaldo())
console.log(c3.consultarSaldo())
```

## A) Qual o resultado dos dois "prints"? Justifique sua resposta.

Resposta: O resultado será 90 de todos os "prints".

Passo a passo:

```TypeScript
c1 = c2; // a variável c1 agora está apontando para o mesmo objeto que c2 aponta
c3 = c1; // a variável c3 agora está apontando para o mesmo objeto que c1 aponta, que é o mesmo que c2 aponta
```
Logo c1, c2, e c3 estão apontando para o mesmo objeto.

```TypeScript
c1.sacar(10); // agora o objeto que c1, c2 e c3 apontam, terá seu saldo atualizado para 90
c1.transferir(c2, 50); // transferir de c1 para c2, é retirar e adicionar no mesmo objeto, pois ambas apontam para uma mesma instância da classe Conta, logo o saldo permanece 90
```

```TypeScript
console.log(c1.consultarSaldo()); // 90
console.log(c2.consultarSaldo()); // 90
console.log(c3.consultarSaldo()); // 90
```

## B) O que acontece com o objeto para o qual a referência c1 apontava?

Resposta: c1 era a única referência para esse objeto, logo ao executar ```c1 = c2```, estamos
fazendo com que c1 aponte para o mesmo objeto que c2 aponta, então aquele objeto que c1 apontava
perdeu sua referência e futuramente será coletado pelo garbage collector, pois agora não 
faz mais sentido ter esse objeto na memória, pois o mesmo não tem mais uma referência, ou seja, 
uma variável que aponte para ele.








